"use strict"; var time_tree; time_tree = function () { var t, n, r, e, i, u, o, a, f, c, s, h, d, l = function (t, n) { for (var r = [], e = function i(t) { var n = t.constructor(); return Object.getOwnPropertyNames(t).forEach(function (r) { n[r] = i(t[r]) }), n }; t > 0;) r[t - 1] = e(n), t -= 1; return r }, v = function (t) { var n = f(t), r = n + c(t); return r - n }, m = function (t, n) { var r = n, e = 0; if (t.Children.length > 0) for (; e < t.Children.length;) r -= v(t.Children[e]), e += 1; return r }, g = function (t) { var n = new Date(f(t)).getTime(), r = n + c(t); return t.st = n, t.et = r, t.duration = m(t, t.et - t.st), e += 1, i.push({ st: n, et: r, duration: t.duration }), time_tree }, b = function (t, n) { for (var r, e, i, u, a, f = 0; f < n.bins.length;) r = n.bins[f], e = n.bins[f + 1], i = r.t, u = void 0 === e ? o : e.t, r.duration = u - r.t, a = h(t, i, u, r.duration), a > 0 && (void 0 === r.bins[t.FriendlyName] ? r.bins[t.FriendlyName] = a : r.bins[t.FriendlyName] += a), f += 1 }, N = function (t) { for (var n = 0; n < t.length;) u > t[n].st && (u = t[n].st), o < t[n].et && (o = t[n].et), n += 1 }, p = function (t, n) { for (var r = []; n > t;) r.push(t), t += 1; return r }, _ = function (t, n) { for (var r = l(n + 1, { t: 0, bins: {} }), e = Math.floor(t.length / n), i = 0, u = 0; n > i;) r[i].t = t[u], u += e, i += 1; return r[n].t = o, r }, y = function (t) { var n = t.length - 1; return 1 * Math.ceil(Math.log(n) / Math.log(2) + 1) + 1 }, O = function () { r = 0, e = 0, i = [], u = Number.MAX_VALUE, o = 0, n = [], d(g, t), N(i); var a = p(u, o); r = y(a); var f = _(a, r); return d(b, t, { bins: f }), f }, w = function (t) { var n = 0; return t.forEach(function (t) { var r = 0, e = 0; t.rects = l(0, 0), Object.getOwnPropertyNames(t.bins).forEach(function (n) { e += t.bins[n] }), Object.getOwnPropertyNames(t.bins).forEach(function (i) { var u = t.bins[i], o = u / e * 100, a = { name: i, p: o, x: n, y: r }; r = o + r, t.rects.push(a) }), n += 1 }), t }; return d = function (t, n, r) { var e, i; return t(n, r), Object.getOwnPropertyNames(a(n)).forEach(function (u) { e = parseInt(u, 10), isNaN(e) || (i = a(n)[e], void 0 !== i && d(t, i, r)) }), time_tree }, s = function (t, n, r, e) { for (var i = 0, u = 0; u < t.Children.length;) i += h(t.Children[u], n, r, e), u += 1; return i }, h = function (t, n, r, e) { if (t.st > r || t.et < n) return 0; if (t.st <= n && t.et >= r) return e - s(t, n, r, e); if (t.st >= n && t.et >= r) return r - t.st - s(t, n, r, e); if (t.st <= n && t.et <= r) return t.et - n - s(t, n, r, e); if (t.st >= n && t.et <= r) return t.duration - s(t, n, r, e); throw "missing condition" }, a = function (t) { return t.children }, f = function (t) { return t.start }, c = function (t) { return t.duration }, { data: function (r) { return t = r, n = [], time_tree }, children: function (t) { return a = t, time_tree }, startTime: function (t) { return f = t, time_tree }, duration: function (t) { return c = t, time_tree }, nodes: function () { return 0 === n.length && (n = O()), n = w(n) }, length: function () { return 0 === n.length && (n = O()), r } } }();